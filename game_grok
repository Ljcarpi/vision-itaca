<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aether Runner</title>
    <!-- README: Aether Runner - A 3D infinite runner game in neon sci-fi corridor. Controls (Desktop): A/D or ←/→ to strafe, W/S or ↑/↓ to dive/ascend, Space to dash. Mobile: Touch buttons for left/right, swipe up/down for lanes, tap for dash. Settings: Access via pause (Esc) for graphics, effects, accessibility. Score saved in localStorage. Restart instantly on game over. -->
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; color: #fff; }
        #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #hud { position: absolute; top: 0; left: 0; width: 100%; padding: 10px; display: flex; justify-content: space-between; font-size: 16px; text-shadow: 0 0 5px #0ff; }
        #controls-help { position: absolute; bottom: 10px; right: 10px; font-size: 14px; text-shadow: 0 0 3px #0ff; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.7); z-index: 10; }
        #overlay h1 { font-size: 48px; text-shadow: 0 0 10px #0ff, 0 0 20px #f0f; margin: 0; }
        #overlay button { background: #0ff; color: #000; border: none; padding: 10px 20px; margin: 10px; font-size: 24px; cursor: pointer; text-shadow: none; }
        #settings { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #0ff; z-index: 20; display: none; }
        #settings label { display: block; margin: 10px 0; }
        #touch-controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 100px; display: none; justify-content: space-around; align-items: center; }
        .touch-btn { background: rgba(0,255,255,0.3); border: 1px solid #0ff; padding: 20px; font-size: 24px; cursor: pointer; }
        svg { fill: #0ff; width: 20px; height: 20px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="hud">
        <div>Score: <span id="score">0</span></div>
        <div>Best: <span id="best">0</span></div>
        <div>Speed: <span id="speed">1x</span></div>
        <div>FPS: <span id="fps">60</span></div>
    </div>
    <div id="controls-help">Controls: A/D strafe, W/S lanes, Space dash</div>
    <div id="overlay" style="display: none;">
        <h1 id="overlay-title">Aether Runner</h1>
        <button id="start-btn">Start</button>
        <button id="resume-btn" style="display: none;">Resume</button>
        <button id="restart-btn" style="display: none;">Restart</button>
        <button id="settings-btn">Settings</button>
    </div>
    <div id="settings">
        <h2>Settings</h2>
        <label>Graphics Quality: <select id="gfx-quality"><option>High</option><option>Medium</option><option>Low</option></select></label>
        <label>Bloom: <input type="checkbox" id="bloom-toggle" checked></label>
        <label>FXAA: <input type="checkbox" id="fxaa-toggle" checked></label>
        <label>Motion Blur: <input type="checkbox" id="motion-blur-toggle" checked></label>
        <label>Color-Blind Mode: <input type="checkbox" id="color-blind"></label>
        <label>Shake Intensity: <input type="range" id="shake-intensity" min="0" max="1" step="0.1" value="0.5"></label>
        <label>Volume: <input type="range" id="volume" min="0" max="1" step="0.1" value="1"></label>
        <button id="close-settings">Close</button>
    </div>
    <div id="touch-controls">
        <div class="touch-btn" id="left-btn">Left</div>
        <div class="touch-btn" id="right-btn">Right</div>
        <div class="touch-btn" id="dash-btn">Dash</div>
    </div>
    <button id="screenshot-btn" style="position: absolute; bottom: 10px; left: 10px; background: #0ff; color: #000; border: none; padding: 5px;">Screenshot</button>
    <script>
        // Game Constants
        const GAME_STATES = { TITLE: 0, PLAYING: 1, PAUSE: 2, GAME_OVER: 3 };
        let state = GAME_STATES.TITLE;
        let score = 0, bestScore = localStorage.getItem('aetherBest') || 0, speed = 1, combo = 1;
        let fps = 60, lastTime = 0, deltaTime = 0;
        let canvas, gl, ctx2d; // WebGL or 2D fallback
        let isWebGL2 = true;
        let audioCtx, masterGain, synthMusic, sfxPickup, sfxNearMiss, sfxDash, sfxHit;
        let settings = { quality: 'High', bloom: true, fxaa: true, motionBlur: true, colorBlind: false, shake: 0.5, volume: 1 };

        // Shaders (inline strings)
        const vertShaderSrc = `
            #version 300 es
            in vec3 aPos;
            in vec3 aNorm;
            uniform mat4 uMVP;
            uniform mat4 uModel;
            out vec3 vNorm;
            out vec3 vPos;
            void main() {
                gl_Position = uMVP * vec4(aPos, 1.0);
                vNorm = mat3(uModel) * aNorm;
                vPos = (uModel * vec4(aPos, 1.0)).xyz;
            }
        `;
        const fragShaderSrc = `
            #version 300 es
            precision highp float;
            in vec3 vNorm;
            in vec3 vPos;
            uniform vec3 uLightPos;
            uniform vec3 uCamPos;
            uniform vec3 uColor;
            uniform float uTime;
            out vec4 fragColor;
            // Simple PBR-like
            float fresnel(vec3 V, vec3 N) { return pow(1.0 - dot(V, N), 5.0); }
            vec3 env(vec3 N) { return mix(vec3(0.1,0.2,0.5), vec3(0.5,0.1,0.8), (N.y + 1.0)*0.5); } // Procedural sky
            void main() {
                vec3 L = normalize(uLightPos - vPos);
                vec3 V = normalize(uCamPos - vPos);
                vec3 N = normalize(vNorm);
                float diff = max(dot(N, L), 0.0);
                vec3 refl = reflect(-L, N);
                float spec = pow(max(dot(V, refl), 0.0), 32.0);
                vec3 base = uColor * diff + vec3(1.0) * spec;
                base += env(N) * 0.2; // Env term
                base += vec3(0.0,1.0,1.0) * sin(uTime + vPos.z * 0.1) * 0.2; // Neon trim
                float rim = fresnel(V, N) * 0.5;
                base += vec3(0.0,1.0,1.0) * rim;
                fragColor = vec4(base, 1.0);
            }
        `;

        // Post-processing shaders (simplified)
        const postVertSrc = `
            #version 300 es
            in vec2 aPos;
            out vec2 uv;
            void main() { gl_Position = vec4(aPos, 0.0, 1.0); uv = aPos * 0.5 + 0.5; }
        `;
        const bloomFragSrc = `
            #version 300 es
            precision highp float;
            uniform sampler2D uTex;
            in vec2 uv;
            out vec4 fragColor;
            void main() {
                vec3 col = texture(uTex, uv).rgb;
                float bright = max(col.r, max(col.g, col.b));
                fragColor = vec4(col * step(1.0, bright), 1.0); // Extract bright
            }
        `;
        // Add more for vignette, FXAA, etc., but keep minimal

        // Geometry buffers (example for craft, track, etc.)
        let craftGeo, trackGeo, obstacleGeos = [], orbGeos = [];

        // Camera, light
        let camera = { pos: [0,0,0], fov: 60, shake: 0 };
        let lightPos = [0,5, -10];

        // Procedural generation
        let chunks = [], seed = 42;
        function rng() { seed = (seed * 16807 % 2147483647); return seed / 2147483647; }
        function generateChunk(z) {
            // Procedural obstacles: gates, bars, etc.
            let obs = [];
            for (let i = 0; i < 5; i++) {
                let type = Math.floor(rng() * 3);
                if (type === 0) obs.push({ type: 'gate', pos: [rng()*4-2, rng()*4-2, z - i*10], size: 2 });
                // etc.
            }
            return obs;
        }

        // Player
        let player = { pos: [0,0,0], lane: 0, dive: 0, dash: false, hitTolerance: 1 };

        // Particles (GPU simple)
        let particles = []; // { pos, vel, life }

        // Input
        let keys = {}, touch = { left: false, right: false, dash: false, swipe: 0 };
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        // Touch events for mobile
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        if (isMobile) {
            document.getElementById('touch-controls').style.display = 'flex';
            document.getElementById('controls-help').innerText = 'Touch: Left/Right buttons, swipe up/down lanes, tap dash';
            // Add touch listeners
            let touchStartY = 0;
            canvas.addEventListener('touchstart', e => {
                touchStartY = e.touches[0].clientY;
                if (e.touches[0].clientX > canvas.width / 2) touch.dash = true;
            });
            canvas.addEventListener('touchmove', e => {
                let dy = e.touches[0].clientY - touchStartY;
                if (dy < -50) touch.swipe = 1; else if (dy > 50) touch.swipe = -1;
            });
            canvas.addEventListener('touchend', e => { touch.dash = false; touch.swipe = 0; });
            document.getElementById('left-btn').addEventListener('touchstart', () => touch.left = true);
            document.getElementById('left-btn').addEventListener('touchend', () => touch.left = false);
            // Similarly for right
        }

        // Audio setup
        function initAudio() {
            audioCtx = new AudioContext();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = settings.volume;
            masterGain.connect(audioCtx.destination);
            // Synth music: simple arpeggio
            synthMusic = audioCtx.createOscillator();
            synthMusic.type = 'sawtooth';
            synthMusic.frequency.value = 220; // A3
            synthMusic.connect(masterGain);
            synthMusic.start();
            // SFX nodes
            sfxPickup = () => { let osc = audioCtx.createOscillator(); osc.type = 'sine'; osc.frequency.value = 880; osc.connect(masterGain); osc.start(); setTimeout(() => osc.stop(), 200); };
            // Similarly for others
        }

        // Init
        function init() {
            canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl = canvas.getContext('webgl2');
            if (!gl) {
                isWebGL2 = false;
                ctx2d = canvas.getContext('2d');
                console.warn('Fallback to 2D Canvas');
            }
            window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
            initAudio();
            loadSettings();
            // Compile shaders
            if (isWebGL2) {
                let program = createProgram(vertShaderSrc, fragShaderSrc);
                gl.useProgram(program);
                // Setup buffers, FBOs for post, etc.
                // HDR FBO
                let hdrTex = gl.createTexture();
                // etc.
            }
            // Generate initial chunks
            for (let i = 0; i < 10; i++) chunks.push(generateChunk(i * 50));
            // UI events
            document.getElementById('start-btn').addEventListener('click', () => startGame());
            document.getElementById('resume-btn').addEventListener('click', () => resumeGame());
            document.getElementById('restart-btn').addEventListener('click', () => restartGame());
            document.getElementById('settings-btn').addEventListener('click', () => showSettings());
            document.getElementById('close-settings').addEventListener('click', () => hideSettings());
            document.getElementById('screenshot-btn').addEventListener('click', () => canvas.toBlob(blob => {
                let a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'aether-runner.png';
                a.click();
            }));
            showOverlay('Aether Runner', ['start-btn', 'settings-btn']);
            requestAnimationFrame(loop);
        }

        // Create shader program
        function createProgram(vert, frag) {
            let vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vert);
            gl.compileShader(vs);
            let fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, frag);
            gl.compileShader(fs);
            let prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            return prog;
        }

        // Game loop
        function loop(time) {
            deltaTime = (time - lastTime) / 1000;
            lastTime = time;
            fps = Math.round(1 / deltaTime);
            document.getElementById('fps').innerText = fps;
            if (fps < 45 && settings.quality !== 'Low') downgradeQuality();
            update();
            render();
            requestAnimationFrame(loop);
        }

        // Update
        function update() {
            if (state !== GAME_STATES.PLAYING) return;
            // Player input
            let strafe = (keys['KeyA'] || keys['ArrowLeft'] || touch.left ? -1 : 0) + (keys['KeyD'] || keys['ArrowRight'] || touch.right ? 1 : 0);
            let laneChange = (keys['KeyW'] || keys['ArrowUp'] ? 1 : 0) + (keys['KeyS'] || keys['ArrowDown'] ? -1 : 0) + touch.swipe;
            player.pos[0] += strafe * deltaTime * 5;
            player.lane += laneChange;
            player.pos[1] = player.lane * 2; // Lanes at y= -4, -2, 0, 2, 4 etc.
            if (keys['Space'] || touch.dash) player.dash = true;
            // Speed ramp
            speed += deltaTime * 0.01;
            player.pos[2] -= speed * deltaTime * 10; // Forward
            document.getElementById('speed').innerText = speed.toFixed(1) + 'x';
            // Generate new chunks if needed
            if (player.pos[2] < chunks[chunks.length-1].z - 50) chunks.push(generateChunk(chunks.length * 50));
            // Collision check (AABB)
            for (let chunk of chunks) {
                for (let obs of chunk) {
                    // Check dist < threshold -> collision or near-miss
                    let dist = Math.hypot(player.pos[0] - obs.pos[0], player.pos[1] - obs.pos[1]);
                    if (dist < 1) { gameOver(); sfxHit(); }
                    else if (dist < 2) { combo++; sfxNearMiss(); particles.push({/*spark*/}); }
                }
            }
            // Orbs collect
            // Score
            score += speed * deltaTime * 10 * combo;
            document.getElementById('score').innerText = Math.floor(score);
            // Camera follow
            camera.pos = [player.pos[0]*0.2, player.pos[1]*0.2, player.pos[2] + 10];
            // Shake
            camera.shake = Math.sin(time*0.001) * settings.shake * 0.1;
            // Light move
            lightPos[2] = player.pos[2] - 5 + Math.sin(time*0.001)*2;
            // Pause on Esc
            if (keys['Escape']) pauseGame();
        }

        // Render
        function render() {
            if (isWebGL2) {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                // Bind program, uniforms (MVP, light, etc.)
                // Draw track: procedural tunnel
                // Quad strips for walls, floor with neon lines
                // Draw obstacles, orbs, craft (simple box/cube geo)
                // Particles: point sprites
                // Post: render to HDR, bloom pass, vignette, etc.
                // Chromatic aberration: sample R/G/B offset
                // Present
            } else {
                // 2D fallback
                ctx2d.clearRect(0,0,canvas.width,canvas.height);
                // Draw flat projections
                // e.g., ctx2d.fillRect(... for obstacles)
            }
        }

        // State changes
        function startGame() {
            state = GAME_STATES.PLAYING;
            hideOverlay();
            synthMusic.frequency.value = 440; // Start music faster
        }
        function pauseGame() {
            state = GAME_STATES.PAUSE;
            showOverlay('Paused', ['resume-btn', 'restart-btn', 'settings-btn']);
        }
        function resumeGame() {
            state = GAME_STATES.PLAYING;
            hideOverlay();
        }
        function gameOver() {
            state = GAME_STATES.GAME_OVER;
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('aetherBest', bestScore);
                document.getElementById('best').innerText = Math.floor(bestScore);
            }
            showOverlay('Game Over', ['restart-btn', 'settings-btn']);
            sfxHit();
        }
        function restartGame() {
            score = 0;
            speed = 1;
            player.pos = [0,0,0];
            player.lane = 0;
            chunks = [];
            for (let i = 0; i < 10; i++) chunks.push(generateChunk(i * 50));
            startGame();
        }

        // Overlay
        function showOverlay(title, btns) {
            document.getElementById('overlay-title').innerText = title;
            document.getElementById('overlay').style.display = 'flex';
            ['start-btn', 'resume-btn', 'restart-btn', 'settings-btn'].forEach(id => document.getElementById(id).style.display = btns.includes(id) ? 'block' : 'none');
        }
        function hideOverlay() { document.getElementById('overlay').style.display = 'none'; }

        // Settings
        function showSettings() { document.getElementById('settings').style.display = 'block'; }
        function hideSettings() { document.getElementById('settings').style.display = 'none'; saveSettings(); }
        function loadSettings() {
            // From localStorage if available
            // Set UI
            document.getElementById('gfx-quality').value = settings.quality;
            // etc.
            // Add change listeners
            document.getElementById('gfx-quality').addEventListener('change', e => settings.quality = e.target.value);
            // Similarly for others
            document.getElementById('volume').addEventListener('input', e => { settings.volume = e.target.value; masterGain.gain.value = settings.volume; });
        }
        function saveSettings() {
            // To localStorage
        }
        function downgradeQuality() {
            if (settings.quality === 'High') settings.quality = 'Medium';
            else if (settings.quality === 'Medium') settings.quality = 'Low';
            // Disable effects accordingly: e.g., if Low, no bloom, no motion blur
            settings.bloom = settings.quality !== 'Low';
            // Update UI
        }

        // Icons as inline SVG (example for settings gear)
        // <svg viewBox="0 0 24 24"><path d="..."/></svg>

        // Run init
        init();
    </script>
</body>
</html>
