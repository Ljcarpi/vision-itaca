<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aether Runner — Single‑File WebGL2 Game</title>
<style>
  :root{
    --bg:#05060a; --fg:#e8f0ff; --muted:#a9b8d6; --accent:#6df0ff; --accent2:#ff6df0;
    --good:#66ff99; --bad:#ff5577; --warn:#ffd166;
  }
  html,body{height:100%;}
  body{margin:0;background:radial-gradient(1200px 800px at 50% -10%, #0e1324 0%, #070912 45%, #04050a 100%);color:var(--fg);font:15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";overflow:hidden;}
  #app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto;}
  header{display:flex;align-items:center;gap:.8rem;padding:.7rem 1rem;background:linear-gradient(180deg,#0b0f1f 0%, #090d1a 100%);border-bottom:1px solid rgba(109,240,255,.12);backdrop-filter: blur(6px);} 
  header .title{font-weight:800;letter-spacing:.3px;text-shadow:0 0 12px rgba(109,240,255,.35), 0 0 28px rgba(255,109,240,.18);} 
  header .pill{margin-left:auto;display:inline-flex;align-items:center;gap:.6rem;padding:.25rem .6rem;border-radius:999px;background:rgba(109,240,255,.08);border:1px solid rgba(109,240,255,.18);font-size:.9rem;color:var(--muted)}
  #hud{position:absolute;inset:0;pointer-events:none;}
  #hud .top{position:absolute;top:.75rem;left:.75rem;right:.75rem;display:flex;gap:.6rem;align-items:center;justify-content:space-between;}
  #hud .stats{display:flex;gap:.6rem;flex-wrap:wrap}
  #hud .stat{pointer-events:auto;background:rgba(14,18,36,.55);border:1px solid rgba(109,240,255,.18);padding:.4rem .6rem;border-radius:.6rem;backdrop-filter:blur(4px)}
  #hud .stat b{color:var(--accent)}
  #hud .center{position:absolute;inset:0;display:grid;place-items:center;}
  #hud .overlay{pointer-events:auto;min-width: min(92vw,560px); max-width:92vw;background:rgba(10,12,22,.72);border:1px solid rgba(109,240,255,.22);box-shadow:0 10px 60px rgba(0,0,0,.45), 0 0 80px rgba(109,240,255,.15);border-radius:16px;padding:22px}
  .overlay h1{margin:.2rem 0 0 0;font-size:1.8rem;letter-spacing:.4px;text-align:center}
  .overlay p{color:var(--muted);margin:.6rem 0 0 0;text-align:center}
  .overlay .row{display:flex;gap:.6rem;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:1rem}
  .btn{pointer-events:auto;background:linear-gradient(180deg,#1b2448,#0e142e);border:1px solid rgba(109,240,255,.25);padding:.55rem .9rem;border-radius:.7rem;color:var(--fg);cursor:pointer;user-select:none;transition:transform .05s ease, box-shadow .2s ease}
  .btn:hover{box-shadow:0 0 24px rgba(109,240,255,.2)}
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:linear-gradient(180deg,#1c2e6b,#11204a);border-color:rgba(109,240,255,.38)}
  .badge{font-size:.85rem;color:var(--muted)}
  footer{display:flex;align-items:center;justify-content:space-between;gap:.8rem;padding:.45rem 1rem;color:var(--muted);border-top:1px solid rgba(109,240,255,.12);background:linear-gradient(180deg,#090d1a 0%, #070912 100%);} 
  #gl{width:100%;height:100%;display:block}
  #mobileCtrls{position:absolute;bottom:1.1rem;left:50%;transform:translateX(-50%);display:none; gap:.8rem;}
  .ctrl{width:64px;height:64px;border-radius:14px;border:1px solid rgba(109,240,255,.2);background:rgba(12,16,30,.55);backdrop-filter:blur(6px);display:grid;place-items:center;font-weight:700}
  .ctrl:active{background:rgba(109,240,255,.18)}
  @media (max-width: 820px){ #mobileCtrls{display:flex} }
  /* tiny help */
  kbd{background:#0e142e;border:1px solid rgba(109,240,255,.25);border-bottom-color:rgba(109,240,255,.35);padding:.05rem .35rem;border-radius:4px}
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">Aether Runner — WebGL2</div>
    <div class="pill">
      <span>Made with inline HTML/CSS/JS • No external assets • WebGL2 + Audio</span>
    </div>
  </header>
  <main style="position:relative">
    <canvas id="gl" aria-label="Game Canvas"></canvas>
    <div id="hud">
      <div class="top">
        <div class="stats">
          <div class="stat">Score: <b id="score">0</b></div>
          <div class="stat">Best: <b id="best">0</b></div>
          <div class="stat">Speed: <b id="spd">0</b></div>
          <div class="stat">FPS: <b id="fps">0</b></div>
        </div>
        <div class="stats" style="justify-content:flex-end">
          <div class="stat"><span class="badge">Controls: <span class="only-desktop"><kbd>A</kbd>/<kbd>D</kbd> or <kbd>←</kbd>/<kbd>→</kbd>, <kbd>Space</kbd> dash, <kbd>Esc</kbd> pause</span><span class="only-mobile"> Touch buttons</span></span></div>
        </div>
      </div>
      <div class="center">
        <div id="title" class="overlay" role="dialog" aria-modal="true">
          <h1>Enter the Neon Tunnel</h1>
          <p>Strafe, dash, and survive. Near-misses boost your combo. Collide and it’s over.</p>
          <div class="row">
            <button class="btn primary" id="play">Play</button>
            <button class="btn" id="settingsBtn">Settings</button>
            <button class="btn" id="screenshot">Screenshot</button>
          </div>
          <p class="badge">Tip: toggle quality if FPS dips. Mobile shows touch controls.</p>
        </div>
        <div id="pause" class="overlay" hidden>
          <h1>Paused</h1>
          <p>Take a breath. The tunnel can wait.</p>
          <div class="row">
            <button class="btn primary" id="resume">Resume</button>
            <button class="btn" id="restart">Restart</button>
            <button class="btn" id="settingsBtn2">Settings</button>
          </div>
        </div>
        <div id="gameover" class="overlay" hidden>
          <h1>Game Over</h1>
          <p><span id="finalScore">0</span> points. Best: <span id="best2">0</span></p>
          <div class="row">
            <button class="btn primary" id="again">Play Again</button>
            <button class="btn" id="settingsBtn3">Settings</button>
            <button class="btn" id="share">Share</button>
          </div>
        </div>
        <div id="settings" class="overlay" hidden>
          <h1>Settings</h1>
          <div class="row" style="flex-direction:column;align-items:stretch">
            <label>Graphics Quality 
              <select id="quality">
                <option value="high">High</option>
                <option value="medium">Medium</option>
                <option value="low">Low</option>
              </select>
            </label>
            <label><input type="checkbox" id="fxaa" checked /> FXAA (edge smoothing)</label>
            <label><input type="checkbox" id="grain" checked /> Film grain</label>
            <label><input type="checkbox" id="shake" checked /> Camera shake</label>
            <label><input type="checkbox" id="cbMode" /> Color‑blind friendly palette</label>
            <label>Master Volume <input id="vol" type="range" min="0" max="1" step="0.01" value="0.5"/></label>
            <div class="row">
              <button class="btn" id="closeSettings">Close</button>
            </div>
          </div>
        </div>
      </div>
      <div id="mobileCtrls">
        <button class="ctrl" id="leftBtn">◄</button>
        <button class="ctrl" id="dashBtn">●</button>
        <button class="ctrl" id="rightBtn">►</button>
      </div>
    </div>
  </main>
  <footer>
    <div>Single‑file demo • No external assets</div>
    <div>Aether Runner © 2025</div>
  </footer>
</div>
<script>
/*
 Aether Runner — Single‑file WebGL2 game
 -------------------------------------------------
 Controls (desktop): A/D or ←/→ to strafe lanes; Space = dash; Esc = pause
 Mobile: on-screen ◄ ● ► controls
 Systems: WebGL2 raymarching tunnel, procedural obstacles, simple FX, WebAudio SFX
 Persist: best score via localStorage
 */
(() => {
  const qs = sel => document.querySelector(sel);
  const canvas = qs('#gl');
  const dpr = Math.min(2, window.devicePixelRatio||1);
  let gl, program, quad, u = {}; // GL objects
  let running = false, paused = false, over = false;
  let width=0, height=0, timeStart=0, last=0, frame=0, fps=0, fpsAcc=0, fpsT=0;
  let score=0, best= +(localStorage.getItem('aether_best')||0);
  let speed=8, baseSpeed=8; // units/sec
  let lane = 0, dashT=0, combo=0;
  let quality = 'high';
  let flags = { fxaa:true, grain:true, shake:true, cb:false };
  let audioCtx, masterGain;
  let obstacleSeed = 1337;

  const UI = {
    score: qs('#score'), best: qs('#best'), spd: qs('#spd'), fps: qs('#fps'),
    title: qs('#title'), pause: qs('#pause'), over: qs('#gameover'),
    final: qs('#finalScore'), best2: qs('#best2'),
    play: qs('#play'), resume: qs('#resume'), restart: qs('#restart'), again: qs('#again'),
    settings: qs('#settings'), settingsBtn: qs('#settingsBtn'), settingsBtn2: qs('#settingsBtn2'), settingsBtn3: qs('#settingsBtn3'),
    quality: qs('#quality'), fxaa: qs('#fxaa'), grain: qs('#grain'), shake: qs('#shake'), cb: qs('#cbMode'), vol: qs('#vol'), closeSettings: qs('#closeSettings'),
    screenshot: qs('#screenshot'), share: qs('#share'),
    leftBtn: qs('#leftBtn'), rightBtn: qs('#rightBtn'), dashBtn: qs('#dashBtn')
  };
  UI.best.textContent = best;

  function rand(seed){ // linear congruential
    let s = seed|0;
    return () => (s = (s*1664525 + 1013904223)|0, ((s>>>0)/4294967296));
  }

  // Obstacles are generated on the fly along Z using a seeded RNG.
  // We keep a small ring buffer of upcoming chunks for CPU-side collisions.
  const chunks = []; // each: {z, pattern:[-1,0,1] with blocked lanes}
  let genZ = 0; // how far we generated
  function genChunks(upTo){
    const rnd = rand(obstacleSeed + (genZ*1000)|0);
    while(genZ < upTo){
      // every 12 units, create a gate pattern; 0..2 blocked lanes count
      const gap = 12;
      const blockedCount = (rnd()<.5)?1: (rnd()<.7?2:1);
      let blocked = new Set();
      while(blocked.size<blockedCount) blocked.add( Math.floor(rnd()*3)-1 );
      chunks.push({ z: genZ+30, blocked: Array.from(blocked) });
      genZ += gap;
    }
  }

  function collide(playerZ){
    // player occupies lane index lane (-1,0,1). Collision if a chunk at ~z in range blocks that lane
    for(const c of chunks){
      if (Math.abs(c.z - playerZ) < 1.2){
        if (c.blocked.includes(lane)) return true;
      }
    }
    return false;
  }

  // WebAudio: tiny synth beeps
  function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = +UI.vol.value;
    masterGain.connect(audioCtx.destination);
  }
  function beep(freq=440, dur=0.08, type='sine', gain=0.08){
    if(!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = gain; g.gain.setTargetAtTime(0.0001, t0+dur*0.6, 0.04);
    o.connect(g); g.connect(masterGain);
    o.start(t0); o.stop(t0+dur);
  }

  // GL utils
  function createGL(){
    gl = canvas.getContext('webgl2', {antialias:false, alpha:false, preserveDrawingBuffer:true});
    if(!gl){ fallback2D(); return; }
    const vs = `#version 300 es
    precision highp float;
    const vec2 verts[4] = vec2[4](vec2(-1.,-1.), vec2(1.,-1.), vec2(-1.,1.), vec2(1.,1.));
    out vec2 vUV; 
    void main(){ vUV = (verts[gl_VertexID]*.5+.5); gl_Position = vec4(verts[gl_VertexID],0.,1.); }
    `;
    const fs = `#version 300 es
    precision highp float; out vec4 o; in vec2 vUV; 
    uniform vec2 uRes; uniform float uTime; uniform float uSpeed; uniform int uLane; 
    uniform int uFXAA; uniform int uGrain; uniform int uShake; uniform int uCB; 
    // Hash/Noise helpers
    uint hash(uvec2 x){ x = (x^ (x>>17u))* 0xED5AD4BBu; x = (x ^ (x>>11u))*0xAC4C1B51u; x = (x ^ (x>>15u))*0x31848BABu; return x.x ^ x.y; }
    float rnd(in vec2 p){ return float(hash(floatBitsToUint(p)))/4294967296.0; }
    // Camera
    mat3 rotY(float a){ float c=cos(a), s=sin(a); return mat3(c,0.,-s, 0.,1.,0., s,0.,c); }
    // Signed distance primitives
    float sdBox(vec3 p, vec3 b){ vec3 q = abs(p)-b; return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0); }
    float sdCyl(vec3 p, vec2 h){ return max(length(p.xz)-h.x, abs(p.y)-h.y); }
    // Map tunnel + obstacles (procedural lanes -1,0,1)
    float map(vec3 p){
      // tunnel radius varies with z
      float r = 3.0 + sin(p.z*0.12 + uTime*0.6)*0.6;
      float tunnel = length(p.xy)-r; // cylindrical tunnel walls
      // obstacles as rotating bars every ~12 units
      float zSeg = floor((p.z+30.)/12.0)*12.0 - 30.0;
      float seed = zSeg*12.7; // stable per-chunk
      float angle = fract(sin(seed)*43758.5453)*6.2831 + uTime*0.4;
      // lanes: -1,0,1 mapped to x offsets
      float laneX[3]; laneX[0] = -1.8; laneX[1] = 0.0; laneX[2] = 1.8;
      // choose blocked lanes from seed
      int blockCount = (int(mod(seed,3.))+1);
      // crude pseudo mask
      int b0 = int(mod(seed*1.7,3.));
      int b1 = int(mod(seed*2.3+1.0,3.));
      // collide bars: rotate a thin box around center of each blocked lane
      float obs = 99.0;
      for(int i=0;i<3;i++){
        bool blocked = (i==b0) || (blockCount>1 && i==b1);
        if(blocked){
          vec3 q = p;
          q.xy -= vec2(laneX[i],0.0);
          mat2 R = mat2(cos(angle),-sin(angle), sin(angle),cos(angle));
          q.xy = R*q.xy;
          float d = sdBox(q, vec3(0.3, r*0.85, 0.6));
          obs = min(obs, d);
        }
      }
      return min(tunnel, obs);
    }
    vec3 neonPalette(float t){
      // colorblind alt palette
      if(uCB==1){
        return mix(vec3(0.08,0.78,0.68), vec3(0.95,0.78,0.12), smoothstep(0.,1.,t));
      }
      vec3 a=vec3(0.5,0.2,0.9), b=vec3(0.5,0.9,0.2), c=vec3(1.0,1.0,1.0), d=vec3(0.0,0.33,0.67);
      return a + b*cos(6.28318*(c*t+d));
    }
    vec3 shade(vec3 ro, vec3 rd){
      float t=0.0; float minT=0.0; float hit=0.0; float glow=0.0; vec3 p;
      for(int i=0;i<128;i++){
        p = ro + rd*t;
        float d = map(p);
        glow += exp(-abs(d)*14.0)*0.006;
        if(abs(d)<0.001){ hit=1.0; break; }
        t += clamp(abs(d), 0.01, 0.25);
        if(t>80.0) break;
      }
      vec3 col = vec3(0.02,0.03,0.08);
      // tunnel neon stripes based on angle and z
      float ang = atan(p.y,p.x);
      float bands = 0.5 + 0.5*cos(ang*16.0 + p.z*0.8 + uTime*2.0);
      vec3 neon = neonPalette(fract(p.z*0.03 + uTime*0.05))*pow(bands, 4.0);
      // fake env light & rim
      vec3 lightDir = normalize(vec3(0.7,0.2,0.5));
      vec3 n = normalize(vec3(0.0));
      // estimate normal via central differences if hit
      if(hit>0.5){
        float e=0.002; float d0 = map(p);
        vec3 gx = vec3(e,0,0), gy=vec3(0,e,0), gz=vec3(0,0,e);
        n = normalize(vec3(map(p+gx)-d0, map(p+gy)-d0, map(p+gz)-d0));
      }
      float ndl = clamp(dot(n, lightDir), 0.0, 1.0);
      float rim = pow(1.0 - max(dot(n,-rd),0.0), 2.5);
      vec3 base = neon*1.4 + vec3(0.03,0.05,0.09);
      col = base*(0.25+0.75*ndl) + rim*vec3(0.4,0.5,0.9);
      col += glow*vec3(1.0,0.7,1.2);
      // fog
      float f = exp(-minT*0.03 - t*0.03);
      col = mix(vec3(0.01,0.02,0.05), col, f);
      return col;
    }
    vec3 fxaaPass(vec2 uv, vec2 res){
      // extremely tiny FXAA-ish: sample 4 neighbors and center
      vec2 px = 1.0/res;
      vec3 c = texture(sampler2D(0), uv).rgb; // NOTE: placeholder (we render single pass; emulate by manual taps below)
      // Without a history buffer, we approximate smoothing by local averaging (not true FXAA)
      vec3 s = vec3(0.0);
      s += texture(sampler2D(0), uv + vec2(-px.x, 0)).rgb;
      s += texture(sampler2D(0), uv + vec2(px.x, 0)).rgb;
      s += texture(sampler2D(0), uv + vec2(0, -px.y)).rgb;
      s += texture(sampler2D(0), uv + vec2(0, px.y)).rgb;
      return mix(c, s*0.25, 0.25);
    }
    void main(){
      vec2 uv = (vUV*2.0-1.0);
      float asp = uRes.x/uRes.y;
      // camera
      float t = uTime;
      float z = t * uSpeed; // forward motion
      float laneX = float(uLane) * 1.8;
      // shake
      if(uShake==1){
        uv += vec2(sin(t*9.7), cos(t*8.3))*0.002;
      }
      // build ray
      vec3 ro = vec3(laneX*0.6, 0.0, z);
      vec3 rd = normalize(vec3(uv.x*asp, uv.y, -1.5));
      rd = rotY(0.05*sin(t*0.6))*rd; // subtle drift
      vec3 col = shade(ro, rd);
      // grain
      if(uGrain==1){
        float g = rnd(uv*vec2(uRes)+t)*0.03; col += g;
      }
      // gamma
      col = pow(max(col,0.0), vec3(0.95));
      o = vec4(col,1.0);
    }`;
    program = link(gl, vs, fs);
    u.uRes = gl.getUniformLocation(program, 'uRes');
    u.uTime = gl.getUniformLocation(program, 'uTime');
    u.uSpeed = gl.getUniformLocation(program, 'uSpeed');
    u.uLane = gl.getUniformLocation(program, 'uLane');
    u.uFXAA = gl.getUniformLocation(program, 'uFXAA');
    u.uGrain = gl.getUniformLocation(program, 'uGrain');
    u.uShake = gl.getUniformLocation(program, 'uShake');
    u.uCB = gl.getUniformLocation(program, 'uCB');
    quad = gl.createVertexArray(); gl.bindVertexArray(quad);
    resize();
    requestAnimationFrame(loop);
  }
  function compile(gl, src, type){
    const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      throw new Error('Shader compile error');
    } return s;
  }
  function link(gl, vsSrc, fsSrc){
    const p = gl.createProgram();
    const vs = compile(gl, vsSrc, gl.VERTEX_SHADER);
    const fs = compile(gl, fsSrc, gl.FRAGMENT_SHADER);
    gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(p));
      throw new Error('Program link error');
    }
    gl.deleteShader(vs); gl.deleteShader(fs);
    return p;
  }

  function resize(){
    const rect = canvas.getBoundingClientRect();
    width = Math.max(320, Math.floor(rect.width * dpr));
    height = Math.max(240, Math.floor(rect.height * dpr));
    canvas.width = width; canvas.height = height;
    gl && gl.viewport(0,0,width,height);
  }
  window.addEventListener('resize', resize);

  // Main loop
  function loop(t){
    if(!gl){ return; }
    const now = t*0.001; if(!timeStart) timeStart = now; const dt = Math.min(0.033, now - (last||now)); last = now;
    frame++; fpsAcc++; fpsT += dt; if(fpsT>0.5){ fps = Math.round(fpsAcc/fpsT); UI.fps.textContent = fps; fpsAcc=0; fpsT=0; }

    gl.useProgram(program); gl.bindVertexArray(quad);
    gl.uniform2f(u.uRes, width, height);

    if(running && !paused && !over){
      // game update
      speed += dt*0.2; // accelerate slowly
      const playerZ = (now - timeStart) * speed;
      genChunks(playerZ + 100);
      // dash timing decay
      dashT = Math.max(0, dashT - dt);
      // collision check
      if(collide(playerZ)){
        gameOver();
        beep(110,0.2,'sawtooth',0.15);
      } else {
        score += dt * (10 + speed*2);
        if(Math.random()<0.005) beep(784,0.03,'triangle',0.03);
      }
      UI.score.textContent = Math.floor(score);
      UI.spd.textContent = speed.toFixed(1);
    }

    gl.uniform1f(u.uTime, now - timeStart);
    gl.uniform1f(u.uSpeed, speed*0.7);
    gl.uniform1i(u.uLane, lane+1); // -1..1 -> 0..2 (shader uses * 1.8)
    gl.uniform1i(u.uFXAA, flags.fxaa?1:0);
    gl.uniform1i(u.uGrain, flags.grain?1:0);
    gl.uniform1i(u.uShake, flags.shake?1:0);
    gl.uniform1i(u.uCB, flags.cb?1:0);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    requestAnimationFrame(loop);
  }

  // Input
  function onKey(e){
    if(e.repeat) return;
    if(e.code==='ArrowLeft' || e.code==='KeyA'){ lane = Math.max(-1, lane-1); if(audioCtx) beep(440,0.06,'square',0.05); }
    if(e.code==='ArrowRight' || e.code==='KeyD'){ lane = Math.min(1, lane+1); if(audioCtx) beep(660,0.06,'square',0.05); }
    if(e.code==='Space'){ dash(); }
    if(e.code==='Escape'){ togglePause(); }
  }
  function dash(){ dashT=0.25; if(audioCtx) beep(990,0.08,'sawtooth',0.08); }
  window.addEventListener('keydown', onKey);

  // UI wiring
  UI.play.onclick = () => start();
  UI.resume.onclick = () => togglePause(false);
  UI.restart.onclick = () => restart();
  UI.again.onclick = () => restart();
  UI.settingsBtn.onclick = () => openSettings();
  UI.settingsBtn2.onclick = () => openSettings();
  UI.settingsBtn3.onclick = () => openSettings();
  UI.closeSettings.onclick = () => closeSettings();
  UI.quality.onchange = () => { quality = UI.quality.value; };
  UI.fxaa.onchange = () => flags.fxaa = UI.fxaa.checked;
  UI.grain.onchange = () => flags.grain = UI.grain.checked;
  UI.shake.onchange = () => flags.shake = UI.shake.checked;
  UI.cb.onchange = () => flags.cb = UI.cb.checked;
  UI.vol.oninput = () => { if(masterGain) masterGain.gain.value = +UI.vol.value; };
  UI.screenshot.onclick = () => {
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = 'aether_runner.png'; a.click();
  };
  UI.share.onclick = async () => {
    const text = `I scored ${Math.floor(score)} in Aether Runner!`;
    if(navigator.share){ try{ await navigator.share({ text, url: location.href }); }catch(_){} }
    else alert(text);
  };

  // Mobile
  UI.leftBtn.onpointerdown = () => { lane = Math.max(-1, lane-1); ensureAudio(); beep(440,0.06,'square',0.05); };
  UI.rightBtn.onpointerdown = () => { lane = Math.min(1, lane+1); ensureAudio(); beep(660,0.06,'square',0.05); };
  UI.dashBtn.onpointerdown = () => { ensureAudio(); dash(); };

  function openSettings(){ UI.settings.hidden=false; UI.title.hidden=true; UI.pause.hidden=true; UI.over.hidden=true; }
  function closeSettings(){ UI.settings.hidden=true; if(!running) UI.title.hidden=false; }

  function start(){
    ensureAudio();
    obstacleSeed = (Math.random()*1e9)|0; chunks.length=0; genZ=0;
    running = true; paused = false; over=false; score=0; speed=baseSpeed; lane=0; dashT=0; timeStart=0; last=0; frame=0;
    UI.title.hidden=true; UI.pause.hidden=true; UI.over.hidden=true;
  }
  function togglePause(force){
    if(!running || over) return;
    paused = (typeof force==='boolean') ? !force : !paused;
    UI.pause.hidden = !paused;
  }
  function gameOver(){
    over = true; running=false; UI.over.hidden=false;
    UI.final.textContent = Math.floor(score);
    best = Math.max(best, Math.floor(score)); localStorage.setItem('aether_best', best);
    UI.best.textContent = best; UI.best2.textContent = best;
  }
  function restart(){ start(); }

  // 2D fallback if WebGL2 unavailable
  function fallback2D(){
    const ctx = canvas.getContext('2d');
    let t0=performance.now();
    function draw2D(){
      const t = (performance.now()-t0)/1000;
      const w=canvas.width=innerWidth*dpr, h=canvas.height=innerHeight*dpr; ctx.scale(1,1);
      const g=ctx;
      // background gradient
      const grd = g.createLinearGradient(0,0,0,h); grd.addColorStop(0,'#0e1324'); grd.addColorStop(1,'#04050a'); g.fillStyle=grd; g.fillRect(0,0,w,h);
      // tunnel rings
      g.strokeStyle='#6df0ff'; g.globalAlpha=.25;
      for(let i=0;i<40;i++){ let z=i*40+(t*200)%40; let r = Math.max(10, (i*8)% (Math.min(w,h)/2)); g.beginPath(); g.arc(w/2,h/2,r,0,Math.PI*2); g.stroke(); }
      g.globalAlpha=1;
      // text
      g.fillStyle='#e8f0ff'; g.font=`${24*dpr}px system-ui`; g.fillText('WebGL2 not available — showing simple 2D fallback', 24*dpr, 40*dpr);
      requestAnimationFrame(draw2D);
    }
    draw2D();
  }

  // bootstrap
  createGL();
  resize();
})();
</script>
</body>
</html>
